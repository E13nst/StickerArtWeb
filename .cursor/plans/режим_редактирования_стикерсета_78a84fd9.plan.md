---
name: "Режим редактирования стикерсета (Фаза 1: UI/UX)"
overview: Реализация UI/UX режима редактирования стикерсета в модалке деталей с локальным состоянием. Изменения порядка стикеров, эмодзи и удаления работают только на фронтенде без интеграции с backend.
todos:
  - id: add-edit-operations-type
    content: Добавить интерфейс StickerSetEditOperations в miniapp/src/types/sticker.ts (только тип, без использования в API)
    status: completed
  - id: add-edit-mode-state
    content: Добавить состояние mode в StickerSetDetail (все остальные состояния редактора - только в StickerSetDetailEdit)
    status: completed
  - id: add-edit-button
    content: Добавить кнопку 'Изменить' для автора в StickerSetDetail (только в режиме view)
    status: completed
    dependencies:
      - add-edit-mode-state
  - id: create-editor-component
    content: Создать компонент StickerSetDetailEdit с локальной логикой редактирования
    status: completed
    dependencies:
      - add-edit-operations-type
  - id: implement-local-operations
    content: Реализовать формирование StickerSetEditOperations из локального состояния (только для логирования)
    status: completed
    dependencies:
      - create-editor-component
  - id: integrate-editor
    content: Интегрировать StickerSetDetailEdit в StickerSetDetail с условным рендерингом по mode
    status: completed
    dependencies:
      - create-editor-component
      - add-edit-button
  - id: add-dnd-support
    content: Добавить drag & drop через @dnd-kit для изменения порядка стикеров
    status: completed
    dependencies:
      - create-editor-component
---

# Реализация режима редактирования стикерсета

## Цель Фазы 1

Реализовать полноценный UI/UX для редактирования стикерсета **только на фронтенде** с локальным состоянием. Все изменения (порядок стикеров, эмодзи, удаление) работают в режиме реального времени, но **не сохраняются на сервере**. Это прототип интерфейса для будущей интеграции с backend.

## Текущие ограничения

**На Фазе 1 мы:**

- ✅ Работаем только с локальным состоянием в React-компонентах
- ✅ Не вызываем новые API-методы
- ✅ Не изменяем существующие HTTP-запросы
- ✅ Не трогаем `api/client.ts`
- ✅ Не изменяем формат body для существующих эндпоинтов

**Изменения видны только во время редактирования и теряются при закрытии модалки или нажатии "Отмена".**

## Изменения в StickerSetDetail (режим view/edit)

### Структурный подход

Чтобы не сломать существующий UI, предлагается:

1. **Вынести текущий контент** в отдельный внутренний компонент `StickerSetDetailView` (или условно рендерить существующий JSX)
2. **Создать новый компонент** `StickerSetDetailEdit` для режима редактирования
3. **Переключать их** по состоянию `mode: 'view' | 'edit'`

### Локальные состояния

В `StickerSetDetail` добавить **только**:

```ts
const [mode, setMode] = useState<'view' | 'edit'>('view');
```

**Важно:** `mode` может быть установлен в `'edit'` **только если** `isAuthor === true`. Для не-авторов `mode` всегда остаётся `'view'`.

**Вся остальная логика редактора** (состояния `editingStickers`, `deletedIds`, `emojiUpdates`) живёт **внутри компонента `StickerSetDetailEdit`**, который получает через пропсы:

- `stickerSet: StickerSetResponse` — исходные данные
- `onCancel: () => void` — колбэк для отмены (возвращает `mode = 'view'`)
- `onDone: (ops: StickerSetEditOperations) => void` — колбэк при нажатии "Готово"

### Кнопка "Изменить"

- Показывается **только если** `isAuthor === true` и `mode === 'view'`
- Располагается рядом с кнопкой редактирования категорий
- При клике:
  - `setMode('edit')` (только если `isAuthor === true`)
  - Компонент `StickerSetDetailEdit` сам инициализирует своё локальное состояние при монтировании

### Важное требование

**Не ломать и не перестраивать текущую разметку режима `view`**, чтобы:

- Не нарушить скролл и свайп-закрытие модалки
- Не сломать layout для не-авторов
- Сохранить все существующие обработчики и эффекты

## Компонент StickerSetDetailEdit (локальный редактор)

### Владелец состояния редактора

**Единственный источник состояния редактора** — компонент `StickerSetDetailEdit`.

`StickerSetDetail`:

- хранит только `mode: 'view' | 'edit'`
- передаёт в `StickerSetDetailEdit` актуальный `stickerSet: StickerSetResponse` и колбэки:
  - `onCancel()` — закрывает edit-режим
  - `onDone(ops: StickerSetEditOperations)` — вызывается при нажатии "Готово"

Внутри `StickerSetDetailEdit` живёт весь редакторский стейт:

- `editingStickers: Sticker[]` — копия массива стикеров для визуального reorder
- `deletedIds: Set<string>` — помеченные на удаление (по `file_id`)
- `emojiUpdates: Record<string, string>` — новые эмодзи по `file_id`

### Источник данных

- Использовать `stickerSet.telegramStickerSetInfo?.stickers ?? []` как начальный список
- **Важно**: обрабатывать кейс `undefined/null`, чтобы избежать ошибок при отсутствии данных
- При монтировании компонента создавать fresh-копию: `useState([...stickerSet.telegramStickerSetInfo?.stickers ?? []])`

### Логика работы

1. **При монтировании компонента**: создаём fresh-копию массива стикеров из `stickerSet.telegramStickerSetInfo?.stickers ?? []`
2. **Изменения не влияют** на исходный `stickerSet`, работаем только с локальным состоянием
3. **На Фазе 1**: эти изменения никуда не сохраняются, только отображаются и логируются

### Работа с Set в React-стейте

**Важное техническое требование:** `Set<string>` можно использовать в стейте React, но **нельзя мутировать предыдущий экземпляр**. Всегда создавать новый Set:

```ts
setDeletedIds(prev => {
  const next = new Set(prev);
  if (next.has(fileId)) {
    next.delete(fileId);
  } else {
    next.add(fileId);
  }
  return next;
});
```

Это обязательное правило реализации, чтобы не сломать обновление UI. React не обнаружит изменения, если мутировать существующий Set напрямую.

### Формирование объекта StickerSetEditOperations

Тип (для локального использования, не в API):

```ts
interface StickerSetEditOperations {
  reorder?: string[];                    // file_id[] в новом порядке
  emojiUpdates?: Record<string, string>; // file_id -> emoji
  deleted?: string[];                    // file_id[] к удалению
}
```

**Как вычисляется:**

1. **`reorder`**: сравнить текущий порядок `editingStickers.map(s => s.file_id)` с исходным `stickerSet.telegramStickerSetInfo.stickers.map(s => s.file_id)`. Если отличается — добавить в `reorder`.
2. **`emojiUpdates`**: собрать все записи из локального `emojiUpdates`, где значение отличается от исходного `sticker.emoji`.
3. **`deleted`**: преобразовать `deletedIds` в массив `string[]`.

### Кнопки управления

**"Отмена":**

- Вызывает `onCancel()` из пропсов
- Родительский компонент `StickerSetDetail` устанавливает `mode = 'view'`
- Локальное состояние `StickerSetDetailEdit` уничтожается при размонтировании

**"Готово":**

1. Вычисляется объект `StickerSetEditOperations`:

   - `reorder`: сравнить порядок `editingStickers.map(s => s.file_id)` с исходным порядком из `stickerSet.telegramStickerSetInfo.stickers.map(s => s.file_id)`. Если отличается — добавить в `reorder`.
   - `emojiUpdates`: собрать все записи из локального `emojiUpdates`, где значение отличается от исходного `sticker.emoji`.
   - `deleted`: преобразовать `deletedIds` в массив `Array.from(deletedIds)`.

2. Если **нет изменений** (порядок не изменился, `emojiUpdates` пустой, `deleted` пустой):

   - просто вызывается `onCancel()` / выход в `view` без уведомлений

3. Если изменения есть:

   - вызывается `onDone(ops)`
   - в Фазе 1 родитель **не вызывает никакой API**, а только:
     - либо логирует `ops` в `console.log('Изменения (не сохраняются):', ops)`
     - либо показывает небольшой Snackbar/alert с текстом: *"Изменения пока не сохраняются на сервере. Это прототип редактора."*
   - затем возвращаемся в `view`-режим (`mode = 'view'`)

**Важно:** В рамках Фазы 1 пользователь **не увидит** перманентных изменений после "Готово". Это ожидаемое поведение, потому что backend ещё не подключен.

## Структура строки стикера (превью, эмодзи, drag-handle, delete)

### Верстка строки

**Финальная композиция строки стикера:**

1. **Слева** — иконка-"бургер" (3 горизонтальные полоски), которая служит drag-handle для перетаскивания
2. **Рядом** — мини-превью стикера (использовать имеющийся компонент `StickerThumbnail` или `LazyThumbnail`)
3. **Далее** — поле для эмодзи (`TextField` из MUI, размером примерно 80-100px)
4. **Справа** — иконка удаления / восстановления (если стикер помечен как удалённый, показывать иконку восстановления)

**Примечание:** Стрелки вверх/вниз не являются основным способом сортировки. Они могут использоваться только как временный fallback, если DnD окажется нестабильным (см. раздел про drag & drop).

### Визуальные состояния

- **Обычный стикер**: нормальная прозрачность, все элементы видны
- **Помеченный на удаление**: сниженная прозрачность (opacity ~0.5), перечёркнутый текст или визуальный индикатор удаления
- **При перетаскивании**: визуальная обратная связь (подсветка, тень, изменение курсора)

## Рекомендации по drag & drop (dnd-kit)

### Приоритет: DnD через burger-handle

**Рекомендуемый путь (приоритет):** использовать `@dnd-kit/core` + `@dnd-kit/sortable`, drag инициируется за "бургер"-иконку слева.

### DnD (Фаза 1, если успеваем)

1. Использовать `@dnd-kit/core` + `@dnd-kit/sortable` для вертикального списка
2. Идентификатором элемента служит `sticker.file_id`
3. Drag-handle — зона с иконкой "бургер" слева от превью (не вся строка)
4. `editingStickers` сортируется на фронте при DnD через `onDragEnd`
5. Это **чистый UI-уровень**, никакого взаимодействия с backend

**Библиотека выбрана по причинам:**

- Хорошо работает с React + TypeScript
- Поддерживает touch-события (важно для Telegram MiniApp)
- Гибкая настройка для flex-вертикальных списков
- Sortable по `id` (в нашем случае `file_id`)
- Активно поддерживается (в отличие от `react-beautiful-dnd`)

### Допустимый fallback

**Если DnD окажется нестабильным в Telegram MiniApp** (конфликты со скроллом/жестами), временно можно оставить простую реализацию `moveUp/moveDown` по клику на стрелки, не ломая архитектуру:

- Кнопки "↑" и "↓" рядом с каждым стикером (вместо или рядом с burger-handle)
- При клике пересортировывать массив `editingStickers` через `setEditingStickers`
- Это временное решение до стабилизации DnD в MiniApp-окружении

## User Flow: автор и неавтор

### Жёсткое ограничение: автор vs не-автор

**Техническое требование:**

- `mode = 'edit'` может быть установлен **только если** `isAuthor === true`
- Кнопка "Изменить" рендерится **только при** `isAuthor === true`
- Для не-авторов:
  - `mode` всегда остаётся `'view'`
  - кнопка "Изменить" не отображается
  - поведение и интерфейс полностью совпадают с текущим продакшен-состоянием

**Таким образом Фаза 1 никак не влияет на опыт обычных пользователей, только на авторов наборов.**

### Неавтор (обычный пользователь)

1. Открывает набор → видит текущий модал с деталями
2. Кнопки "Изменить" и edit-режима **нет**
3. Поведение полностью совпадает с текущим продом
4. **Никаких изменений в UX для неавторов**

### Автор набора

1. Открывает свой набор → видит кнопку **"Изменить"** (только для автора)
2. Нажимает "Изменить":

   - Модал остаётся тем же
   - Контент внутри переключается в режим редактора (список стикеров)
   - Скрываются "витринные" элементы (лайки, share) для удобства

3. В режиме редактирования:

   - Перетаскивает строки за "бургер"-иконку (или использует кнопки ↑/↓ как fallback)
   - Редактирует эмодзи в полях
   - Помечает некоторые стикеры как удалённые (кнопка удаления)

4. Нажимает:

   - **"Отмена"** → все изменения забываются, возвращаемся к обычному виду
   - **"Готово"** → локально собираем `StickerSetEditOperations`, логируем/показываем, что сохранение пока не реализовано, возвращаемся к виду

**Важно:** На Фазе 1 пользователь **не увидит постоянных изменений после "Готово"**, это прототип UI. Сохранение появится в Фазе 2.

## Фаза 2 (будущее, без задач и без кода)

### Контекст для будущей интеграции

В будущем UI должен будет отправлять на сервер объект `StickerSetEditOperations` со следующей структурой:

```ts
interface StickerSetEditOperations {
  reorder?: string[];                    // file_id[] в новом порядке
  emojiUpdates?: Record<string, string>; // file_id -> emoji
  deleted?: string[];                    // file_id[] к удалению
}
```

Backend получит этот объект и обработает изменения через соответствующие вызовы Telegram Bot API. Конкретные эндпоинты и формат HTTP-запроса будут определены позже.

**На Фазе 1 мы не реализуем эту интеграцию, только подготавливаем UI для будущего контракта.**